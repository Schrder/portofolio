---
// The abstraction is leaking here, because the order of the images is important
// the consumer shouldn't have to care in which order the images are passed
// maybe it is fair to say I am not making an abstraction for the picture element
// but I am making an abstraction for the duplicate code and the srcset generation
interface ImageMetadata {
  title: string;
  sizes?: string;
  media?: string;
}

export interface Props {
  className?: string;
  loading?: "eager" | "lazy";
  images: ImageMetadata[];
}

const { loading = "lazy", className, images } = Astro.props;
const prefix = `${import.meta.env.BASE_URL}assets`;
const widths = [400, 800, 1200, 1600, 2000, 2400];

const generateSrcset = (title: string, filetype: "jpeg" | "avif"): string => {
  let srcset = "";
  widths.forEach((width) => {
    const variationName = `${prefix}/${title}_${width}px`;
    srcset += `${variationName}.${filetype} ${width}w`;
    if (width !== widths[widths.length - 1]) {
      srcset += ",";
    }
  });

  return srcset;
};

const fallbackImage = `${prefix}/${images[0].title}_800px.jpg`;
---

<style>
  img {
    width: 100%;
    height: 100%;
    object-fit: cover;

    /* Remove intrinsice widths of replacement element */
    min-width: 0;
    min-height: 0;

    border-radius: 8px;
    background-color: var(--variant-2);
    object-position: var(--photo-object-position, 50% 50%);
  }
</style>
<picture class={className}>
  {
    images?.map(({ title, sizes = "100vw", media }: ImageMetadata) => (
      <>
        <source
          type="image/avif"
          media={media}
          srcset={generateSrcset(title, "avif")}
          sizes={sizes}
        />
        <source
          type="image/jpeg"
          media={media}
          srcset={generateSrcset(title, "jpeg")}
          sizes={sizes}
        />
      </>
    ))
  }
  <img
    src={fallbackImage}
    alt={images[0].title}
    loading={loading}
    id={images[0].title}
  />
</picture>
